<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1'/>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Hostile Developer - Filtering through subqueries in ActiveRecord</title>
  <link href="/favicon.ico" rel="icon" type="image/ico" />
  <link href="/stylesheets/application.css" rel="stylesheet" type="text/css" />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />
</head>
<body>
<div id="container">
  <section id="header">
  <header>
<a href="/">        <h1 class="brand"><span class="hostile">Hostile</span> Developer</h1>
        <h4 class="tag-line">I am Steven. Hear me Rant.</h4>
</a>  </header>

  <section class='social'>
    <a href="http://twitter.com/_StevenNunez/" target="_blank"><i class="fa fa-twitter"></i></a>
    <a href="https://github.com/StevenNunez/" target="_blank"><i class="fa fa-github"></i></a>
  </section>
</section>


  <main id='article' role="main">
    <h1 class="article-title"><a href="/2019/12/12/filtering-through-subqueries-in-activerecord.html">Filtering through subqueries in ActiveRecord</a></h1>
    <p>I had a requirement this week to implement some filtering logic. This post is a collection of my learnings. The domain has been changed a bit the concepts are the same.</p>

<h2>Course Tracker</h2>

<p>Code can be found <a href="https://github.com/StevenNunez/course_tracker">Here</a>. The domain is pretty straight forward. For our purposes, let&rsquo;s focus on the Courses.</p>

<p>A Course has many <code>ratings</code>. One query we&rsquo;re interested in is finding a course with a minimum average rating.</p>

<p>In SQL, fetching courses with a rating of 2 or higher would look something like:</p>
<div class="highlight"><pre class="highlight sql"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">courses</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">ratings</span>
<span class="k">ON</span> <span class="n">ratings</span><span class="p">.</span><span class="n">course_id</span> <span class="o">=</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">HAVING</span> <span class="k">AVG</span><span class="p">(</span><span class="n">ratings</span><span class="p">.</span><span class="n">rating</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>ActiveRecord makes this super easy:</p>
<div class="highlight"><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="no">Course</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:ratings</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"AVG(ratings.rating) &gt; 2"</span><span class="p">)</span>
<span class="c1"># =&gt; #&lt;ActiveRecord::Relation [#&lt;Course id: 1, name: "Cooking", created_at: "2019-12-12 00:49:38", updated_at: "2019-12-12 00:49:38"&gt;, #&lt;Course id: 2, name: "Learn to Code", created_at: "2019-12-12 00:49:38", updated_at: "2019-12-12 00:49:38"&gt;]&gt;</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>RUBY I LOVE YOU ❤️ ❤️ ❤️. This returns 2 records. Both with an average rating over 2.</p>

<p>Our next filtering task was to find courses matching a list of tags. This one is tricky since we want to only return courses that match ALL the tags.</p>

<p>Our <a href="https://github.com/StevenNunez/course_tracker/blob/master/db/seeds.rb#L25">seed data</a> shows that we have a few courses that are tagged as &ldquo;Fun&rdquo;, but only one that is also tagged as &ldquo;Food&rdquo;</p>

<p>What would this look like in SQL if we were looking for &ldquo;Fun&rdquo; and &ldquo;Food&rdquo;?</p>
<div class="highlight"><pre class="highlight sql"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">courses</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">taggings</span>
<span class="k">ON</span> <span class="n">taggings</span><span class="p">.</span><span class="n">course_id</span> <span class="o">=</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">tags</span>
<span class="k">ON</span> <span class="n">taggings</span><span class="p">.</span><span class="n">tag_id</span> <span class="o">=</span> <span class="n">tags</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">tags</span><span class="p">.</span><span class="n">name</span> <span class="k">IN</span> <span class="p">(</span><span class="nv">"Fun"</span><span class="p">,</span> <span class="nv">"Food"</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>This one is funky. Let&rsquo;s walk through the thinking.
If a tag doesn&rsquo;t match at all, it won&rsquo;t produce a row since we&rsquo;re using an <code>INNER JOIN</code>.
If only 1 of our tags match, then we&rsquo;ll get a row that describes the course and JUST that tag.</p>

<p>However (this is the cool bit), if both tags match, we&rsquo;ll get 2(!) with the same course, but with the tag that matched.</p>

<p>Take a look at the result without any of the <code>GROUP BY</code> and <code>HAVING</code> business.</p>
<div class="highlight"><pre class="highlight sql"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="n">courses</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tags</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> <span class="n">courses</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">taggings</span>
<span class="k">ON</span> <span class="n">taggings</span><span class="p">.</span><span class="n">course_id</span> <span class="o">=</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">tags</span>
<span class="k">ON</span> <span class="n">taggings</span><span class="p">.</span><span class="n">tag_id</span> <span class="o">=</span> <span class="n">tags</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">tags</span><span class="p">.</span><span class="n">name</span> <span class="k">IN</span> <span class="p">(</span><span class="nv">"Fun"</span><span class="p">,</span> <span class="nv">"Food"</span><span class="p">)</span>
<span class="c1">--name        name      </span>
  <span class="c1">----------  ----------</span>
<span class="c1">--Cooking     Food      </span>
<span class="c1">--Cooking     Fun       </span>
<span class="c1">--Learn to C  Fun    </span>
</pre></td></tr></tbody></table></code></pre></div>
<p>We want the one that matches the count of the tags we passed in.</p>

<p>After the filtering we&rsquo;re left with just the one Course.</p>
<div class="highlight"><pre class="highlight sql"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="n">courses</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">tags</span><span class="p">.</span><span class="n">name</span>
<span class="k">FROM</span> <span class="n">courses</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">taggings</span>
<span class="k">ON</span> <span class="n">taggings</span><span class="p">.</span><span class="n">course_id</span> <span class="o">=</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">tags</span>
<span class="k">ON</span> <span class="n">taggings</span><span class="p">.</span><span class="n">tag_id</span> <span class="o">=</span> <span class="n">tags</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">tags</span><span class="p">.</span><span class="n">name</span> <span class="k">IN</span> <span class="p">(</span><span class="nv">"Fun"</span><span class="p">,</span> <span class="nv">"Food"</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="c1">--name        name      </span>
<span class="c1">------------  ----------</span>
<span class="c1">--Cooking     Food </span>
</pre></td></tr></tbody></table></code></pre></div>
<p>In ActiveRecord, this looks something like this:</p>
<div class="highlight"><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Food"</span><span class="p">,</span> <span class="s2">"Fun"</span><span class="p">]</span>
<span class="no">Course</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:tags</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">tags: </span><span class="p">{</span><span class="ss">name: </span><span class="n">tags</span><span class="p">}).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"COUNT(*) = ?"</span><span class="p">,</span> <span class="n">tags</span><span class="p">.</span><span class="nf">count</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation [#&lt;Course id: 1, name: "Cooking", created_at: "2019-12-12 00:49:38", updated_at: "2019-12-12 00:49:38"&gt;]&gt;</span>
</pre></td></tr></tbody></table></code></pre></div>
<h2>Filters on Filters</h2>

<p>This works, but what we&rsquo;re trying to do is refine results like a sieve. In SQL, you&rsquo;d use subqueries for that.</p>

<p>Say we wanted to combine our 2 examples, finding courses with a rating of 2 and above, AND with the tags of &ldquo;Food&rdquo; and &ldquo;Fun&rdquo;. That&rsquo;s a lot of constraints! We could so something like this in SQL:</p>
<div class="highlight"><pre class="highlight sql"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="o">*</span>
<span class="k">FROM</span> <span class="n">courses</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">taggings</span>
<span class="k">ON</span> <span class="n">taggings</span><span class="p">.</span><span class="n">course_id</span> <span class="o">=</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">tags</span>
<span class="k">ON</span> <span class="n">taggings</span><span class="p">.</span><span class="n">tag_id</span> <span class="o">=</span> <span class="n">tags</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span> <span class="n">tags</span><span class="p">.</span><span class="n">name</span> <span class="k">IN</span> <span class="p">(</span><span class="nv">"Fun"</span><span class="p">,</span> <span class="nv">"Food"</span><span class="p">)</span>
<span class="k">AND</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span> <span class="k">IN</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
                   <span class="k">FROM</span> <span class="n">courses</span>
                   <span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">ratings</span>
                   <span class="k">ON</span> <span class="n">ratings</span><span class="p">.</span><span class="n">course_id</span> <span class="o">=</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
                   <span class="c1">-- WHERE (further constraints go here...)</span>
                   <span class="k">GROUP</span> <span class="k">BY</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
                   <span class="k">HAVING</span> <span class="k">AVG</span><span class="p">(</span><span class="n">ratings</span><span class="p">.</span><span class="n">rating</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="n">courses</span><span class="p">.</span><span class="n">id</span>
<span class="k">HAVING</span> <span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>SUBQUERIES. We&rsquo;d continue to refine the queries with more subqueries if needed.</p>

<p>What does this look like in ActiveRecord? SO EASY.</p>
<div class="highlight"><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="n">rating</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">tags</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"Food"</span><span class="p">,</span> <span class="s2">"Fun"</span><span class="p">]</span>
<span class="n">ratings_query</span> <span class="o">=</span> <span class="no">Course</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:ratings</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"avg(ratings.rating) &gt; ?"</span><span class="p">,</span> <span class="n">rating</span><span class="p">)</span>
<span class="no">Course</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">ratings_query</span><span class="p">.</span><span class="nf">all</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:tags</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">tags: </span><span class="p">{</span><span class="ss">name: </span><span class="n">tags</span><span class="p">}).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"id"</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"COUNT(*) = ?"</span><span class="p">,</span> <span class="n">tags</span><span class="p">.</span><span class="nf">count</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation [#&lt;Course id: 1, name: "Cooking", created_at: "2019-12-12 00:49:38", updated_at: "2019-12-12 00:49:38"&gt;]&gt;</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>It works! Not only that, take a look at what calling <code>to_sql</code> returns from our second query.</p>
<div class="highlight"><pre class="highlight sql"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="k">SELECT</span> <span class="nv">"courses"</span><span class="p">.</span><span class="o">*</span>
<span class="k">FROM</span> <span class="nv">"courses"</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">"taggings"</span>
<span class="k">ON</span> <span class="nv">"taggings"</span><span class="p">.</span><span class="nv">"course_id"</span> <span class="o">=</span> <span class="nv">"courses"</span><span class="p">.</span><span class="nv">"id"</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">"tags"</span> <span class="k">ON</span> <span class="nv">"tags"</span><span class="p">.</span><span class="nv">"id"</span> <span class="o">=</span> <span class="nv">"taggings"</span><span class="p">.</span><span class="nv">"tag_id"</span>
<span class="k">WHERE</span> <span class="nv">"courses"</span><span class="p">.</span><span class="nv">"id"</span> <span class="k">IN</span> <span class="p">(</span>
                    <span class="k">SELECT</span> <span class="nv">"courses"</span><span class="p">.</span><span class="nv">"id"</span>
                    <span class="k">FROM</span> <span class="nv">"courses"</span>
                    <span class="k">INNER</span> <span class="k">JOIN</span> <span class="nv">"ratings"</span>
                    <span class="k">ON</span> <span class="nv">"ratings"</span><span class="p">.</span><span class="nv">"course_id"</span> <span class="o">=</span> <span class="nv">"courses"</span><span class="p">.</span><span class="nv">"id"</span>
                    <span class="k">GROUP</span> <span class="k">BY</span> <span class="nv">"courses"</span><span class="p">.</span><span class="nv">"id"</span>
                    <span class="k">HAVING</span> <span class="p">(</span><span class="k">avg</span><span class="p">(</span><span class="n">ratings</span><span class="p">.</span><span class="n">rating</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
                    <span class="p">)</span>
<span class="k">AND</span> <span class="nv">"tags"</span><span class="p">.</span><span class="nv">"name"</span> <span class="k">IN</span> <span class="p">(</span><span class="s1">'Food'</span><span class="p">,</span> <span class="s1">'Fun'</span><span class="p">)</span>
<span class="k">GROUP</span> <span class="k">BY</span> <span class="nv">"courses"</span><span class="p">.</span><span class="nv">"id"</span>
<span class="k">HAVING</span> <span class="p">(</span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>Thanks ActiveRecord!!</p>

<h2>Putting it all together.</h2>

<p>Let&rsquo;s define an interface for these queries.</p>

<p>Calling <code>CourseQueryBuilder.new.run(tag: [&quot;Food&quot;, &quot;Fun&quot;], min_rating: 2)</code> should get us the same record</p>

<p>First thing we do is always make <em>all</em> our queries take a <code>where</code> subquery and wrap them in methods. Those methods should receive the previous query.</p>
<div class="highlight"><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">CourseQueryBuilder</span>
  <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
   <span class="c1"># More to come </span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">by_tag_list</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">tags</span><span class="p">)</span>
    <span class="no">Course</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">query</span><span class="p">.</span><span class="nf">all</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:tags</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">tags: </span><span class="p">{</span><span class="ss">name: </span><span class="n">tags</span><span class="p">}).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"id"</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"COUNT(*) = ?"</span><span class="p">,</span> <span class="n">tags</span><span class="p">.</span><span class="nf">count</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="k">def</span> <span class="nf">by_min_rating</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">rating</span><span class="p">)</span>
    <span class="no">Course</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">query</span><span class="p">.</span><span class="nf">all</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:ratings</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"avg(ratings.rating) &gt; ?"</span><span class="p">,</span> <span class="n">rating</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>Next let&rsquo;s define <code>#run</code>. In this method we&rsquo;re going to iterate over all of the facets (keys) and constraints (values) provided. If we find something we can filter, we call the corresponding method, if we don&rsquo;t we return the last returned query. Sounds like a job for <code>Enum.reduce</code>!</p>
<div class="highlight"><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">CourseQueryBuilder</span>
  <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
    <span class="n">params</span><span class="p">.</span><span class="nf">reduce</span><span class="p">(</span><span class="no">Course</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">query</span><span class="p">,</span> <span class="p">(</span><span class="n">facet</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span><span class="o">|</span>
      <span class="k">case</span> <span class="n">facet</span>
      <span class="k">when</span> <span class="ss">:tag</span>
        <span class="n">by_tag_list</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
      <span class="k">when</span> <span class="ss">:min_rating</span>
        <span class="n">by_min_rating</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">constraint</span><span class="p">)</span>
      <span class="k">else</span>
        <span class="n">query</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">by_tag_list</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">tags</span><span class="p">)</span>
    <span class="no">Course</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">query</span><span class="p">.</span><span class="nf">all</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:tags</span><span class="p">).</span><span class="nf">where</span><span class="p">(</span><span class="ss">tags: </span><span class="p">{</span><span class="ss">name: </span><span class="n">tags</span><span class="p">}).</span><span class="nf">group</span><span class="p">(</span><span class="s2">"id"</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"COUNT(*) = ?"</span><span class="p">,</span> <span class="n">tags</span><span class="p">.</span><span class="nf">count</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">by_min_rating</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">rating</span><span class="p">)</span>
    <span class="no">Course</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">id: </span><span class="n">query</span><span class="p">.</span><span class="nf">all</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:ratings</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">having</span><span class="p">(</span><span class="s2">"avg(ratings.rating) &gt; ?"</span><span class="p">,</span> <span class="n">rating</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>We pass in <code>Course</code> as the first query since we want to start with all records. Each reduction we reduce the amount of records by applying more queries.</p>

<p>Here&rsquo;s our rating query returning our 2 Courses:</p>
<div class="highlight"><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="no">CourseQueryBuilder</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">min_rating: </span><span class="mi">2</span><span class="p">)</span>
<span class="c1">#=&gt; #&lt;ActiveRecord::Relation [#&lt;Course id: 1, name: "Cooking", created_at: "2019-12-12 00:49:38", updated_at: "2019-12-12 00:49:38"&gt;, #&lt;Course id: 2, name: "Learn to Code", created_at: "2019-12-12 00:49:38", updated_at: "2019-12-12 00:49:38"&gt;]&gt;</span>
</pre></td></tr></tbody></table></code></pre></div>
<p>And here&rsquo;s the combined result:</p>
<div class="highlight"><pre class="highlight ruby"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="no">CourseQueryBuilder</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">run</span><span class="p">(</span><span class="ss">min_rating: </span><span class="mi">2</span><span class="p">,</span> <span class="ss">tag: </span><span class="p">[</span><span class="s2">"Food"</span><span class="p">,</span> <span class="s2">"Fun"</span><span class="p">])</span>
<span class="c1">#=&gt; #&lt;ActiveRecord::Relation [#&lt;Course id: 1, name: "Cooking", created_at: "2019-12-12 00:49:38", updated_at: "2019-12-12 00:49:38"&gt;]&gt;</span>
</pre></td></tr></tbody></table></code></pre></div>
<h2>Summary</h2>

<p>Subqueries give you a ton of power by allowing you to write simple composable code that&rsquo;s easy to maintain, and understand.</p>

<p>I hope this was useful!</p>

    <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'hostiledeveloper'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

  </main>

 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48123503-1', 'auto');
  ga('send', 'pageview');

</script>

 <em>Copyright &copy; 2019 Steven Nu&ntilde;ez - HostileDeveloper</em>

</div>
</body>
</html>
