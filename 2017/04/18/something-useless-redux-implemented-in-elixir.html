<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta http-equiv='X-UA-Compatible' content='IE=edge;chrome=1'/>
  <title>Hostile Developer - Something Useless - Redux Implemented in Elixir</title>
  <link href="/stylesheets/application.css" rel="stylesheet" type="text/css" />
  <link rel="alternate" type="application/atom+xml" title="Atom Feed" href="/feed.xml" />

</head>
<body>
<div id="container">
  <section id="header">
  <header>
<a href="/">        <h1 class="brand"><span class="hostile">Hostile</span> Developer</h1>

        <h3 class="tag-line">I am Steven. Hear me Rant.</h3>
</a>  </header>

  <section class='social'>
    <a target="_blank" href="http://twitter.com/_StevenNunez/"><i class="fa fa-twitter"></i></a>
    <a target="_blank" href="https://github.com/StevenNunez/"><i class="fa fa-github"></i></a>
  </section>
  <nav>
    <ul class='links'>
      <li><a href="/">Home</a></li>
    </ul>
  </nav>
</section>


  <main id='articles' role="main">
    <h1 class="article-title"><a href="/2017/04/18/something-useless-redux-implemented-in-elixir.html">Something Useless - Redux Implemented in Elixir</a></h1>
    <h1>Something completely useless - Redux Implemented in Elixir</h1>

<p>I got a chance to teach <a href="http://redux.js.org/">Redux</a> recently and what a time! For something so simple, it sure can get complicated. If you take a look at my <a href="/2014/04/13/closures.html">previous articles</a> you might notice a technique I use to get my head around concepts. Bring that bad boy on to my own turf.</p>

<p><img src="https://media.giphy.com/media/OhQBBFi64Z81a/giphy.gif" /></p>

<p>A na√Øve implementation of Redux using JavaScript might look something like this:</p>
<pre class="highlight javascript"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre></td><td class="rouge-code"><pre><span class="kr">const</span> <span class="nx">initializerAction</span> <span class="o">=</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s2">"@@INIT"</span><span class="p">}</span>
<span class="kr">const</span> <span class="nx">createStore</span> <span class="o">=</span> <span class="p">(</span><span class="nx">reducer</span><span class="p">,</span> <span class="nx">state</span><span class="o">=</span><span class="kc">undefined</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
<span class="nx">state</span> <span class="o">=</span> <span class="nx">reducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">initializerAction</span><span class="p">)</span>
<span class="kd">let</span> <span class="nx">subscribers</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">getState</span><span class="p">()</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">state</span>
    <span class="p">},</span>
    <span class="nx">subscribe</span><span class="p">(</span><span class="nx">subscriber</span><span class="p">){</span>
      <span class="nx">subscribers</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">subscriber</span><span class="p">)</span>
      <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">subscribers</span> <span class="o">=</span> <span class="nx">subscribers</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">s</span> <span class="o">=&gt;</span> <span class="nx">s</span> <span class="o">!==</span> <span class="nx">subscriber</span><span class="p">)</span>
      <span class="p">}</span>
    <span class="p">},</span>
    <span class="nx">dispatch</span><span class="p">(</span><span class="nx">action</span><span class="p">){</span>
      <span class="nx">state</span> <span class="o">=</span> <span class="nx">reducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span>
      <span class="nx">subscribers</span><span class="p">.</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">s</span> <span class="o">=&gt;</span> <span class="nx">s</span><span class="p">())</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">countReducer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">switch</span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">){</span>
    <span class="k">case</span> <span class="s2">"INCREMENT"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="na">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">countReducer</span><span class="p">)</span>
<span class="kr">const</span> <span class="nx">removeSubscriber</span> <span class="o">=</span> <span class="nx">store</span><span class="p">.</span><span class="nx">subscribe</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">"I got called"</span><span class="p">,</span> <span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">()))</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s2">"INCREMENT"</span><span class="p">})</span>
<span class="c1">// Should log "I got called: 1"</span>

<span class="nx">removeSubscriber</span><span class="p">()</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s2">"INCREMENT"</span><span class="p">})</span>
<span class="c1">// Should log nothing"</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Cool. So we can build out a store that calls a single reducer. The store can notify subscribers of changes. We&rsquo;ll work on implementing this in Elixir, and we&rsquo;ll even handle the case with combined reducers. Along the way, we&rsquo;ll see where the JavaScript implementation falters, blocking execution of independent reducers and how to get around that in Elixir.</p>

<h1>Let&rsquo;s dream</h1>

<p>The code of my dreams looks something like:</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">store</span><span class="p">}</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="no">CountReducer</span><span class="p">)</span>

<span class="n">subscriber_ref</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="sd">"</span><span class="s2">I Got called: </span><span class="si">#{</span><span class="n">state</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span><span class="p">)</span>

<span class="no">Store</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">})</span>
<span class="c1"># Should log "I got called: 1"</span>

<span class="no">Store</span><span class="o">.</span><span class="n">remove_subscriber</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">subscriber_ref</span><span class="p">)</span>
<span class="no">Store</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">})</span>
<span class="c1"># Should log nothing"</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>We swapped out a few things. This is Elixir so we&rsquo;re passing in a reference to the <code>Store</code> pid on every invocation. We also changed how we unsubscribe from a store, returning a reference value instead of a function that magically calls in the right scope. Also, we pass the current state to the subscribers on every call. This looks great, but how do we build it?</p>

<h2>Enter the GenServer</h2>

<p>I <em>love</em> the Erlang lords for creating the GenServer. It works for EVERYTHING.
Let&rsquo;s start by implementing the <code>get_state</code> function on a <code>Store</code> process.</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="k">defmodule</span> <span class="no">Store</span> <span class="k">do</span>
  <span class="nv">@initializer_action</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">@@INIT"</span><span class="p">}</span>

  <span class="c1"># Code your Mom calls</span>
  <span class="k">def</span> <span class="n">start_link</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="n">initial_state</span> <span class="p">\\</span> <span class="no">nil</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="bp">__MODULE__</span><span class="p">,</span> <span class="p">[</span><span class="n">reducer</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">])</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">get_state</span><span class="p">(</span><span class="n">store</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">{</span><span class="ss">:get_state</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="c1"># Code Joe Armstrong Calls</span>
  <span class="k">def</span> <span class="n">init</span><span class="p">([</span><span class="n">reducer</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">])</span> <span class="k">do</span>
    <span class="n">store_state</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="ss">:reduce</span><span class="p">,</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">,</span> <span class="nv">@initializer_action</span><span class="p">])</span>
    <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{</span><span class="ss">reducer:</span> <span class="n">reducer</span><span class="p">,</span> <span class="ss">store_state:</span> <span class="n">store_state</span><span class="p">}}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span><span class="ss">:get_state</span><span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
    <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="ss">:store_state</span><span class="p">),</span> <span class="n">state</span><span class="p">}</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>The code above will use the <code>apply</code> function to dispatch a message to a module. If our reducer is a module named <code>CountReducer</code>, it would call <code>CountReducer.reduce(state, action)</code>. Pretty nice.</p>

<p>The reducer will be a module with a <code>reduce/2</code> function. Reducers have a few responsibilities.
* They provide default values for state on initialization
* They return a new version of state based on an action being passed
* They ignore messages it doesn&rsquo;t care for</p>

<p>The Reducers don&rsquo;t care what the state is, all they do is get state, and an action, then respond with new state. Here&rsquo;s a sample reducer:</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="k">defmodule</span> <span class="no">Reducer</span> <span class="k">do</span>
  <span class="nv">@callback</span> <span class="n">reduce</span><span class="p">(</span><span class="n">any</span><span class="p">,</span> <span class="no">Map</span> <span class="p">::</span> <span class="n">map</span><span class="p">())</span> <span class="p">::</span> <span class="n">any</span>
<span class="k">end</span>

<span class="k">defmodule</span> <span class="no">CountReducer</span> <span class="k">do</span>
  <span class="nv">@behaviour</span> <span class="no">Reducer</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">action</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">reduce</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_reduce</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>

  <span class="k">defp</span> <span class="n">do_reduce</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">}),</span> <span class="k">do</span><span class="p">:</span> <span class="n">state</span> <span class="o">+</span> <span class="m">1</span>
  <span class="k">defp</span> <span class="n">do_reduce</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">state</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>We first create a <code>behaviour</code> to ensure anyone that plays the <code>Reducer</code> role knows how to do the job. We need it to have a <code>reduce/2</code> function to support the <code>Store</code> module&rsquo;s expectation. The rest is just some good old fashioned PATTERN MATCHING. The first 2 <code>reduce/2</code> heads are just clean up. If we get a nil value, then just call it again with a 0, our <code>do_reduce/2</code> functions are where the actual reducing happens.</p>

<h2>Time to run it</h2>

<p>Throw all of that in a file named <code>e_dux.exs</code> a open up <code>iex</code>.</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="n">c</span> <span class="sd">"</span><span class="s2">e_dux.exs"</span>

<span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">store</span><span class="p">}</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="no">CountReducer</span><span class="p">)</span>
<span class="no">Store</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">store</span><span class="p">)</span> <span class="c1"># =&gt; 0</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Not too exciting. Let&rsquo;s add the ability to <code>dispatch</code> an action. Back in our <code>Store</code>:</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="k">defmodule</span> <span class="no">Store</span> <span class="k">do</span>
  <span class="c1"># Code for your Mom</span>
  <span class="c1"># Existing Mom code...</span>
  <span class="k">def</span> <span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span> <span class="k">do</span>
    <span class="no">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">{</span><span class="ss">:dispatch</span><span class="p">,</span> <span class="n">action</span><span class="p">})</span>
  <span class="k">end</span>

  <span class="c1"># Code for Joe Armstrong</span>
  <span class="c1"># Existing Joe code...</span>
  <span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:dispatch</span><span class="p">,</span> <span class="n">action</span><span class="p">},</span> <span class="p">%{</span><span class="ss">reducer:</span> <span class="n">reducer</span><span class="p">,</span> <span class="ss">store_state:</span> <span class="n">store_state</span><span class="p">}</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">store_state</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="ss">:reduce</span><span class="p">,</span> <span class="p">[</span><span class="n">store_state</span><span class="p">,</span> <span class="n">action</span><span class="p">])</span>
    <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="ss">:store_state</span><span class="p">,</span> <span class="n">store_state</span><span class="p">)}</span>
  <span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Here we cast asynchronously using <code>GenServer.cast/2</code>. This strategy makes it so our dispatch code won&rsquo;t block our calling code. Imagine if a reducer took a long time to finish. Or better yet, imagine if we have to run through several reducers? This not blocking takes advantage of Elixir&rsquo;s real power: Concurrency. Try this out by loading the file like before and run this:</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="n">c</span> <span class="sd">"</span><span class="s2">e_dux.exs"</span>

<span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">store</span><span class="p">}</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="no">CountReducer</span><span class="p">)</span>
<span class="no">Store</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">store</span><span class="p">)</span> <span class="c1"># =&gt; 0</span>
<span class="no">Store</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">})</span>
<span class="no">Store</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">store</span><span class="p">)</span> <span class="c1"># =&gt; 1</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>WOOT! Got some <code>INCREMENT</code> action! Let&rsquo;s move on to adding subscribers and notifying them.</p>

<h2>I&rsquo;d like to subscribe to your newsletter</h2>

<p>Back to our dream code:</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">store</span><span class="p">}</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="no">CountReducer</span><span class="p">)</span>

<span class="n">subscriber_ref</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="sd">"</span><span class="s2">I Got called: </span><span class="si">#{</span><span class="n">state</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span><span class="p">)</span>

<span class="no">Store</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">})</span>
<span class="c1"># Should log "I got called: 1"</span>

<span class="no">Store</span><span class="o">.</span><span class="n">remove_subscriber</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">subscriber_ref</span><span class="p">)</span>
<span class="no">Store</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">})</span>
<span class="c1"># Should log nothing"</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>We want a <code>dispatch</code> to notify our existing subscribers after we&rsquo;ve updated our state. We&rsquo;ll also have our <code>store</code> track its subscribers. We&rsquo;ll be updating <code>init/1</code>, as well as adding <code>subscribe/2</code> and <code>remove_subscriber/2</code></p>

<h3>init/1</h3>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="n">init</span><span class="p">([</span><span class="n">reducer</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">])</span> <span class="k">do</span>
  <span class="n">store_state</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="ss">:reduce</span><span class="p">,</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">,</span> <span class="nv">@initializer_action</span><span class="p">])</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{</span><span class="ss">reducer:</span> <span class="n">reducer</span><span class="p">,</span> <span class="ss">store_state:</span> <span class="n">store_state</span><span class="p">,</span> <span class="ss">subscribers:</span> <span class="p">%{}}}</span> <span class="c1"># add new subscribers map to state</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Here we add a new key to our state map: subscribers. We&rsquo;ll be taking advantage of this being a map when we delete subscribers in <code>remove_subscriber/2</code></p>

<h3>subscribe/2 remove_subscriber/2 and call backs</h3>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="c1"># For mama</span>
<span class="k">def</span> <span class="n">subscribe</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">GenServer</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">{</span><span class="ss">:subscribe</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">})</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">remove_subscriber</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="k">do</span>
  <span class="no">GenServer</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">{</span><span class="ss">:remove_subscriber</span><span class="p">,</span> <span class="n">ref</span><span class="p">})</span>
<span class="k">end</span>

<span class="c1"># For Joey</span>
<span class="k">def</span> <span class="n">handle_call</span><span class="p">({</span><span class="ss">:subscribe</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">},</span> <span class="n">_from</span><span class="p">,</span> <span class="p">%{</span><span class="ss">subscribers:</span> <span class="n">subscribers</span><span class="p">}</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">ref</span> <span class="o">=</span> <span class="n">make_ref</span><span class="p">()</span>
  <span class="p">{</span><span class="ss">:reply</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">put_in</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">[</span><span class="ss">:subscribers</span><span class="p">,</span> <span class="n">ref</span><span class="p">],</span> <span class="n">subscriber</span><span class="p">)}</span>
<span class="k">end</span>

<span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:remove_subscriber</span><span class="p">,</span> <span class="n">ref</span><span class="p">},</span> <span class="p">%{</span><span class="ss">subscribers:</span> <span class="n">subscribers</span><span class="p">}</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">subscribers</span> <span class="o">=</span> <span class="no">Map</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">subscribers</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="ss">:subscribers</span><span class="p">,</span> <span class="n">subscribers</span><span class="p">)}</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Our <code>subscribe/2</code> function will add our subscriber to our map, storing a <code>ref</code> as the key. Since a ref is a unique value, it&rsquo;s a great way to well&hellip; reference stuff. We&rsquo;ll return that <code>ref</code> to our caller. <code>remove_subscriber/2</code> takes a <code>store</code> pid and a <code>ref</code>. This updates our <code>subscriber</code> map. This is done in a <code>cast</code> since we don&rsquo;t care about the return value.</p>

<h3>dispatch/2</h3>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:dispatch</span><span class="p">,</span> <span class="n">action</span><span class="p">},</span> <span class="p">%{</span><span class="ss">reducer:</span> <span class="n">reducer</span><span class="p">,</span> <span class="ss">store_state:</span> <span class="n">store_state</span><span class="p">,</span> <span class="ss">subscribers:</span> <span class="n">subscribers</span><span class="p">}</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">store_state</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="ss">:reduce</span><span class="p">,</span> <span class="p">[</span><span class="n">store_state</span><span class="p">,</span> <span class="n">action</span><span class="p">])</span>
  <span class="n">for</span> <span class="p">{</span><span class="n">_ref</span><span class="p">,</span> <span class="n">sub</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="n">subscribers</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="p">(</span><span class="n">store_state</span><span class="p">)</span> <span class="c1"># notify those subscribers</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="ss">:store_state</span><span class="p">,</span> <span class="n">store_state</span><span class="p">)}</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>FINALLY we update <code>handle_cast/2</code> for our <code>dispatch/2</code> function to call every subscriber.</p>

<p>With this code, our dreams are ALIVE!</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">store</span><span class="p">}</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">start_link</span><span class="p">(</span><span class="no">CountReducer</span><span class="p">)</span>

<span class="n">subscriber_ref</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="k">fn</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="o">-&gt;</span>
    <span class="no">IO</span><span class="o">.</span><span class="n">puts</span> <span class="sd">"</span><span class="s2">I Got called: </span><span class="si">#{</span><span class="n">state</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span><span class="p">)</span>

<span class="no">Store</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">})</span>
<span class="c1"># Should log "I got called: 1"</span>

<span class="no">Store</span><span class="o">.</span><span class="n">remove_subscriber</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="n">subscriber_ref</span><span class="p">)</span>
<span class="no">Store</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">})</span>
<span class="c1"># Should log nothing"</span>
</pre></td></tr></tbody></table>
</code></pre>
<h2>Combined Reducers</h2>

<p>So Redux lets you break down complex logic into multiple reducers. Something like:</p>
<pre class="highlight javascript"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="kr">const</span> <span class="nx">rootReducer</span> <span class="o">=</span> <span class="nx">combineReducers</span><span class="p">({</span>
  <span class="na">count</span><span class="p">:</span> <span class="nx">countReducer</span><span class="p">,</span>
  <span class="na">square</span><span class="p">:</span> <span class="nx">squareReducer</span>
<span class="p">})</span>

<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">)</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">()</span> <span class="c1">// {count: 0, square: 2} // default to 2 so we can get some good squaring action</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">({</span><span class="na">type</span><span class="p">:</span> <span class="s2">"INCREMENT"</span><span class="p">})</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">getState</span><span class="p">()</span> <span class="c1">// {count: 1, square: 4}</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Internally all a combined reducer is is a reducer that delegates to other reducers. More naive code:</p>
<pre class="highlight javascript"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre><span class="kr">const</span> <span class="nx">combineReducers</span> <span class="o">=</span> <span class="p">(</span><span class="nx">reducerMap</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">Object</span><span class="p">.</span><span class="nx">keys</span><span class="p">(</span><span class="nx">reducerMap</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">map</span><span class="p">,</span> <span class="nx">stateName</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">map</span><span class="p">[</span><span class="nx">stateName</span><span class="p">]</span> <span class="o">=</span> <span class="nx">reducerMap</span><span class="p">[</span><span class="nx">stateName</span><span class="p">](</span><span class="nx">state</span><span class="p">[</span><span class="nx">stateName</span><span class="p">],</span> <span class="nx">action</span><span class="p">)</span>
      <span class="k">return</span> <span class="nx">map</span>
    <span class="p">},</span> <span class="p">{})</span>  
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">countReducer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">state</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s2">"INCREMENT"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="na">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">squareReducer</span> <span class="o">=</span> <span class="p">(</span><span class="nx">state</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="s2">"INCREMENT"</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span> <span class="o">*</span> <span class="nx">state</span>
    <span class="na">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="nx">state</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kr">const</span> <span class="nx">rootReducer</span> <span class="o">=</span> <span class="nx">combineReducers</span><span class="p">({</span><span class="na">count</span><span class="p">:</span> <span class="nx">countReducer</span><span class="p">,</span> <span class="na">square</span><span class="p">:</span> <span class="nx">squareReducer</span><span class="p">})</span>
<span class="nx">rootReducer</span><span class="p">({</span><span class="na">count</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">square</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="na">type</span><span class="p">:</span> <span class="s2">"INCREMENT"</span><span class="p">})</span> <span class="c1">// {count: 1, square: 4}</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Here we return a function that when called with a state and action will delegate portions of the state to specific reducers. Pretty nice! But something wicked lies in this code. When our reducer dispatches, it can only delegate to one reducer at a time, even though their state is completely isolated. This would be a perfect time for some concurrency! Let&rsquo;s look at how we can handle this in Elixir.</p>

<h3>CombineReducer Module</h3>

<p>We&rsquo;ll start out with a change to how treat individual reducers vs a Map with reducers. Above our existing <code>init/1</code> function, add this:</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre><span class="c1"># New stuff!</span>
<span class="k">def</span> <span class="n">init</span><span class="p">([</span><span class="n">reducer_map</span><span class="p">,</span> <span class="no">nil</span><span class="p">])</span> <span class="ow">when</span> <span class="n">is_map</span><span class="p">(</span><span class="n">reducer_map</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">init</span><span class="p">([</span><span class="n">reducer_map</span><span class="p">,</span> <span class="p">%{}])</span>
<span class="k">def</span> <span class="n">init</span><span class="p">([</span><span class="n">reducer_map</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">])</span> <span class="ow">when</span> <span class="n">is_map</span><span class="p">(</span><span class="n">reducer_map</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">store_state</span> <span class="o">=</span> <span class="no">CombineReducers</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">reducer_map</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">,</span> <span class="nv">@initializer_action</span><span class="p">)</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{</span><span class="ss">reducer:</span> <span class="n">reducer_map</span><span class="p">,</span> <span class="ss">store_state:</span> <span class="n">store_state</span><span class="p">,</span> <span class="ss">subscribers:</span> <span class="p">%{}}}</span> <span class="c1"># add new subscribers map to state</span>
<span class="k">end</span>

<span class="c1"># Crusty old code</span>
<span class="k">def</span> <span class="n">init</span><span class="p">([</span><span class="n">reducer</span><span class="p">,</span> <span class="n">initial_state</span><span class="p">])</span> <span class="k">do</span>
  <span class="n">store_state</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="ss">:reduce</span><span class="p">,</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">,</span> <span class="nv">@initializer_action</span><span class="p">])</span>
  <span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="p">%{</span><span class="ss">reducer:</span> <span class="n">reducer</span><span class="p">,</span> <span class="ss">store_state:</span> <span class="n">store_state</span><span class="p">,</span> <span class="ss">subscribers:</span> <span class="p">%{}}}</span> <span class="c1"># add new subscribers map to state</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Converting nil values to an empty map will let our reducers receive <code>nil</code> as their state when we call something like <code>state[:count]</code>. They&rsquo;ll then convert that to their expected default state.</p>

<p>One small change to <code>dispatch/2</code> to support our reducer potentially being a map instead of a module:</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="c1"># New hotness</span>
<span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:dispatch</span><span class="p">,</span> <span class="n">action</span><span class="p">},</span> <span class="p">%{</span><span class="ss">reducer:</span> <span class="n">reducer_map</span><span class="p">,</span> <span class="ss">store_state:</span> <span class="n">store_state</span><span class="p">,</span> <span class="ss">subscribers:</span> <span class="n">subscribers</span><span class="p">}</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="ow">when</span> <span class="n">is_map</span><span class="p">(</span><span class="n">reducer_map</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">store_state</span> <span class="o">=</span> <span class="no">CombineReducers</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">reducer_map</span><span class="p">,</span> <span class="n">store_state</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
  <span class="n">for</span> <span class="p">{</span><span class="n">_ref</span><span class="p">,</span> <span class="n">sub</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="n">subscribers</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="p">(</span><span class="n">store_state</span><span class="p">)</span> <span class="c1"># notify those subscribers</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="ss">:store_state</span><span class="p">,</span> <span class="n">store_state</span><span class="p">)}</span>
<span class="k">end</span>

<span class="c1"># Old and crust</span>
<span class="k">def</span> <span class="n">handle_cast</span><span class="p">({</span><span class="ss">:dispatch</span><span class="p">,</span> <span class="n">action</span><span class="p">},</span> <span class="p">%{</span><span class="ss">reducer:</span> <span class="n">reducer</span><span class="p">,</span> <span class="ss">store_state:</span> <span class="n">store_state</span><span class="p">,</span> <span class="ss">subscribers:</span> <span class="n">subscribers</span><span class="p">}</span> <span class="o">=</span> <span class="n">state</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">store_state</span> <span class="o">=</span> <span class="n">apply</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="ss">:reduce</span><span class="p">,</span> <span class="p">[</span><span class="n">store_state</span><span class="p">,</span> <span class="n">action</span><span class="p">])</span>
  <span class="n">for</span> <span class="p">{</span><span class="n">_ref</span><span class="p">,</span> <span class="n">sub</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="n">subscribers</span><span class="p">,</span> <span class="k">do</span><span class="p">:</span> <span class="n">sub</span><span class="o">.</span><span class="p">(</span><span class="n">store_state</span><span class="p">)</span> <span class="c1"># notify those subscribers</span>
  <span class="p">{</span><span class="ss">:noreply</span><span class="p">,</span> <span class="no">Map</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="ss">:store_state</span><span class="p">,</span> <span class="n">store_state</span><span class="p">)}</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>And finally, our brand new module a brand new module to handle our CombineReducers logic.</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre><span class="k">defmodule</span> <span class="no">CombineReducers</span> <span class="k">do</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">reducers</span><span class="p">,</span> <span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">for</span> <span class="p">{</span><span class="n">state_name</span><span class="p">,</span> <span class="n">reducer</span><span class="p">}</span> <span class="o">&lt;-</span> <span class="n">reducers</span> <span class="k">do</span>
      <span class="no">Task</span><span class="o">.</span><span class="n">async</span><span class="p">(</span><span class="k">fn</span> <span class="p">()</span> <span class="o">-&gt;</span>
        <span class="p">{</span><span class="n">state_name</span><span class="p">,</span> <span class="n">apply</span><span class="p">(</span><span class="n">reducer</span><span class="p">,</span> <span class="ss">:reduce</span><span class="p">,</span> <span class="p">[</span><span class="n">state</span><span class="p">[</span><span class="n">state_name</span><span class="p">],</span> <span class="n">action</span><span class="p">])}</span>
      <span class="k">end</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="o">&amp;</span><span class="no">Task</span><span class="o">.</span><span class="n">await</span><span class="o">/</span><span class="m">1</span><span class="p">)</span>
    <span class="o">|&gt;</span> <span class="no">Enum</span><span class="o">.</span><span class="n">into</span><span class="p">(%{})</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Ok, dopeness alert. Notice how we&rsquo;re using a task to run this calculation. This means that the calculation for ALL of the reducers will take as long as the slowest one, not the culmination of all of their time. THIS IS REALLY COOL. How are you not excited?!</p>

<p>Let&rsquo;s test it out. First create a <code>SquareReducer</code>:</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre><span class="k">defmodule</span> <span class="no">SquareReducer</span> <span class="k">do</span>
  <span class="nv">@behaviour</span> <span class="no">Reducer</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="no">nil</span><span class="p">,</span> <span class="n">action</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">reduce</span><span class="p">(</span><span class="m">2</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>
  <span class="k">def</span> <span class="n">reduce</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">do_reduce</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">action</span><span class="p">)</span>

  <span class="k">defp</span> <span class="n">do_reduce</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">}),</span> <span class="k">do</span><span class="p">:</span> <span class="n">state</span> <span class="o">*</span> <span class="m">1</span>
  <span class="k">defp</span> <span class="n">do_reduce</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">_</span><span class="p">),</span> <span class="k">do</span><span class="p">:</span> <span class="n">state</span>
<span class="k">end</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>Then Run this!</p>
<pre class="highlight elixir"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre><span class="p">{</span><span class="ss">:ok</span><span class="p">,</span> <span class="n">store</span><span class="p">}</span> <span class="o">=</span> <span class="no">Store</span><span class="o">.</span><span class="n">start_link</span><span class="p">(%{</span><span class="ss">count:</span> <span class="no">CountReducer</span><span class="p">,</span> <span class="ss">square:</span> <span class="no">SquareReducer</span><span class="p">})</span>

<span class="no">Store</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="n">store</span><span class="p">,</span> <span class="p">%{</span><span class="ss">type:</span> <span class="sd">"</span><span class="s2">INCREMENT"</span><span class="p">})</span>
<span class="no">Store</span><span class="o">.</span><span class="n">get_state</span><span class="p">(</span><span class="n">store</span><span class="p">)</span>
</pre></td></tr></tbody></table>
</code></pre>
<p>SO COOL!!!</p>

<h1>Closing up</h1>

<p>This bit of hacking really deepend my understanding of Redux, how combined reducers worked, and what their limitations where. I also got a chance to work on some interesting Elixir. I don&rsquo;t really have a use for this pattern. It seems like it might be stepping on some of the same pain points you&rsquo;d solve with <a href="https://hexdocs.pm/elixir/GenEvent.html">GenEvent</a>. Thanks for reading.</p>

<p>Want to see more of something mentioned here? Leave any ideas in the comments below.</p>

<p><a href="https://gist.github.com/StevenNunez/cd955e1f1576397c01c528ba41a88730">Here&rsquo;s a gist with the code</a>. Happy Clacking.</p>

    <div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
    var disqus_shortname = 'hostiledeveloper'; // required: replace example with your forum shortname

    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

  </main>

  <aside id="history">
    <section class="recent">
      <h2>Recent Articles</h2>
      <ol class="articles">
            <li><a href="/2017/04/18/something-useless-redux-implemented-in-elixir.html">Something Useless - Redux Implemented in Elixir</a>
            <li><a href="/2016/08/24/learn-to-program-with-elixir.html">Learn to Program with Elixir</a>
            <li><a href="/2016/05/23/guard-this-with-your-life-or-authenticating-apis-with-guardian.html">Guard this with your life... Or authenticating APIs with Guardian</a>
            <li><a href="/2016/05/22/ltrees-in-phoenix.html">LTrees in Phoenix</a>
            <li><a href="/2016/04/26/processes-in-elixir.html">Processes in Elixir</a>
            <li><a href="/2016/02/24/hey-watch-it-or-how-to-monitor-files-in-elixir.html">Hey! Watch it!...or how to monitor files in Elixir</a>
            <li><a href="/2015/08/23/let-s-build-something-with-rack.html">Let's build something with Rack</a>
            <li><a href="/2015/08/21/lets-learn-about-rack.html">Let's learn about Rack</a>
            <li><a href="/2015/06/08/rails-foreign-key-constraints-the-ugly-way.html">Rails Foreign Key Constraints - The Ugly Way</a>
            <li><a href="/2015/05/28/working-with-templates-in-ruby-erb.html">Working with Templates in Ruby ERB</a>
      </ol>
    </section>

    <section class="tags">
      <h2>Tags</h2>
      <ol>
            <li><a href="/tags/beginner.html">Beginner</a> (1)</a></li>
            <li><a href="/tags/concurrency.html">Concurrency</a> (1)</a></li>
            <li><a href="/tags/ecto.html">Ecto</a> (1)</a></li>
            <li><a href="/tags/elixir.html">Elixir</a> (3)</a></li>
            <li><a href="/tags/ltrees.html">LTrees</a> (1)</a></li>
            <li><a href="/tags/learn-to-program.html">Learn to Program</a> (1)</a></li>
            <li><a href="/tags/phoenix.html">Phoenix</a> (1)</a></li>
            <li><a href="/tags/processes.html">Processes</a> (1)</a></li>
            <li><a href="/tags/random-thoughts.html">Random Thoughts</a> (1)</a></li>
            <li><a href="/tags/authentication.html">authentication</a> (1)</a></li>
            <li><a href="/tags/basics.html">basics</a> (1)</a></li>
            <li><a href="/tags/beginner.html">beginner</a> (1)</a></li>
            <li><a href="/tags/closures.html">closures</a> (1)</a></li>
            <li><a href="/tags/components-of-programming.html">components of programming</a> (1)</a></li>
            <li><a href="/tags/elixir.html">elixir</a> (4)</a></li>
            <li><a href="/tags/enumerable.html">enumerable</a> (1)</a></li>
            <li><a href="/tags/file-watchers.html">file watchers</a> (1)</a></li>
            <li><a href="/tags/find.html">find</a> (1)</a></li>
            <li><a href="/tags/fs.html">fs</a> (1)</a></li>
            <li><a href="/tags/fundamentals.html">fundamentals</a> (1)</a></li>
            <li><a href="/tags/generators.html">generators</a> (1)</a></li>
            <li><a href="/tags/guardian.html">guardian</a> (1)</a></li>
            <li><a href="/tags/javascript.html">javascript</a> (3)</a></li>
            <li><a href="/tags/learning.html">learning</a> (1)</a></li>
            <li><a href="/tags/navigation.html">navigation</a> (1)</a></li>
            <li><a href="/tags/phoenix.html">phoenix</a> (1)</a></li>
            <li><a href="/tags/polyglot.html">polyglot</a> (1)</a></li>
            <li><a href="/tags/postgresql.html">postgresql</a> (1)</a></li>
            <li><a href="/tags/promises.html">promises</a> (1)</a></li>
            <li><a href="/tags/rack.html">rack</a> (2)</a></li>
            <li><a href="/tags/rails.html">rails</a> (2)</a></li>
            <li><a href="/tags/redux.html">redux</a> (1)</a></li>
            <li><a href="/tags/routing.html">routing</a> (1)</a></li>
            <li><a href="/tags/ruby.html">ruby</a> (6)</a></li>
            <li><a href="/tags/sharp-axe.html">sharp axe</a> (1)</a></li>
            <li><a href="/tags/web.html">web</a> (1)</a></li>
      </ol>
    </section>
    <section class="by-month">
      <h2>By Month</h2>
      <ol>
            <li><a href="/2017/04.html">April 2017</a>
              (1)</a></li>
            <li><a href="/2016/08.html">August 2016</a>
              (1)</a></li>
            <li><a href="/2016/05.html">May 2016</a>
              (2)</a></li>
            <li><a href="/2016/04.html">April 2016</a>
              (1)</a></li>
            <li><a href="/2016/02.html">February 2016</a>
              (1)</a></li>
            <li><a href="/2015/08.html">August 2015</a>
              (2)</a></li>
            <li><a href="/2015/06.html">June 2015</a>
              (1)</a></li>
            <li><a href="/2015/05.html">May 2015</a>
              (2)</a></li>
            <li><a href="/2015/02.html">February 2015</a>
              (1)</a></li>
            <li><a href="/2014/11.html">November 2014</a>
              (1)</a></li>
            <li><a href="/2014/05.html">May 2014</a>
              (1)</a></li>
            <li><a href="/2014/04.html">April 2014</a>
              (2)</a></li>
            <li><a href="/2014/02.html">February 2014</a>
              (1)</a></li>
            <li><a href="/2013/10.html">October 2013</a>
              (1)</a></li>
      </ol>
    </section>
  </aside>
 <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48123503-1', 'auto');
  ga('send', 'pageview');

</script>

</div>
</body>
</html>
